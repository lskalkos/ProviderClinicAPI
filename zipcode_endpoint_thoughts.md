# Zipcode Endpoint Thoughts

* First impressions: We have a class called ZipCodeEndpoint with several methods that are procedural / functional in nature rather than object oriented. There‚Äôs nothing inherently wrong with functional / procedural programming ‚Äî there are other languages and frameworks that are meant to be used in a functional programming style, but Ruby is object oriented at heart and I think there will big benefits here to refactoring it to be more OOO, which I will get into. 
* The name of this class seems quite broad ‚Äî I suspect the class is handling more responsibility than it should and looking it through it confirms that thought for me. It appears the ZipcodeEndpoint class knows the external Zipcode API and how to contact it, how to query PartnerClinic, how to sort partner clinics, and how to do serialization. Encapsulating and drawing some better architectural boundaries on this code will help make it easier to read and change for the next developer. 
* The single public method on this class is `get_zip_in_radius`, so I start looking at it to see what it‚Äôs doing and what it might return. I have to do quite a bit of jumping around in the class to track down what the other invoked methods are doing. Methods with more than 1 or 2 parameters tend to be a code smell in Ruby and there are lots of those here. 
* The first thing I try to do is understand what the code is doing and what the expected results are from it. I read through the comments and the code and understand that we have a set of partner clinics in a relational database, which have a zipcode and a tier attribute. Given a zipcode and a radius as an input, the code is using the external Zip Code API to find other nearby zip codes, and then it uses that data to return a list of partner clinics ordered by tier and distance from the initial input zipcode. I think this solution overall is clever. If we were always querying partner clinics from a set point, we could save the distance from the set point for each clinic in the database. It makes sense though that we'd want to be able to find nearby clinics from any location, in which case the problem is a dynamic one and saving distances directly to the database won't work. So I like that this solution uses the Zip Code API to do the legwork of finding out the distances of given zipcodes from a starting zipcode. 
* It takes me longer than I‚Äôd like to figure out what the code is doing and I‚Äôm still not 100% sure I‚Äôm right about that. Specs would be critical to code like this. Ideally we‚Äôd have a request / integration level spec for the API that ensures the response is correct, and other specs that drill down to the unit test level. Ideally each method in the class would be covered by one or more associated specs. If this code didn‚Äôt have any specs, I would minimally write out a lot of test cases for `get_zip_in_radius` to lean on and prevent regressions before I refactor. 
* The most complex method in the code is `sort_extracted_zips_from_db_by_distance`, which has two if statements (one with an OR), and two nested loops. My guess is that Rubocop would alert on the cyclomatic complexity of this method. I relied heavily upon one of the comments to understand what it was doing ("Sort ZIP codes in the same tier by distance‚Äù) as I genuinely couldn‚Äôt figure it out from reading it. I am not entirely convinced that the code works like it says it does. In real life I would really hope this logic had good spec coverage, otherwise I would make sure it did first (which might require discussion with a product manager!) to ensure we‚Äôre actually returning the data in the correct order. I  appreciate the developer leaving some comments though and would have liked more. Sometimes developers hesitate to leave comments because of the belief that the code should speak for itself, which is of course ideal, but in practice comments can be really helpful.
* Overall this code reminds me a little of the example in Sandi Metz‚Äôs talk the ‚ÄúGilded Rose‚Äù: https://www.youtube.com/watch?v=8bZh5LMaSmE and I would try to use her strategies here. After reading through the code, I would ‚Äúrewind‚Äù it a little and actually start putting the logic from the other methods back in to `get_zip_in_radius`, so I can get it back into a state where I can see the connections between variables and arguments and make better abstractions out of it. I expect complexity to spike during the refactor and for the code to get messier before it gets better. That's the process and I‚Äôm cool with it üôÇ 
* All this being said, I think it's important to consider what the real life context might be behind this code. We can definitely make this code better, but sometimes there are real trade offs in terms of time, priorties, people available to do work, etc. There could be other problems that are more pressing for the business that could put refactoring this code lower down on the list. The original developer might have had good reasons to use a nested loop that I don't discover until I have my hands deep in it. It all depends on context and where we can have the most impact as developers. 
* Please see my code samples for further thoughts on where we could take a refactor!
